//am_graph.hpp 邻接矩阵实现
#pragma once
#include <vector>
#include <iostream>
#include <string>
#include <map>
#include <queue>
#include <stdexcept>
#include <climits>
#include <cstdio>
#include "union_find_set.hpp"

namespace limou
{
	using std::vector;
	using std::string;
	using std::cout;
	using std::map;
	using std::invalid_argument;
	using std::queue;
	using std::priority_queue;
	using std::greater;

	template <
		typename VertexType = char, //顶点数据类型
		typename WeightType = int, //权重数据类型
		WeightType MAX_W = INT_MAX, //表示无穷的数
		bool Direction = false //判断是否有向
	>
	class AMGraph
	{
		/*
		* 无向图或有向图（考虑带权值）邻接矩阵模板类，
		* 测试有三种方法：IO 输入、文件读取样例、手动在代码中添加
		*/
		typedef AMGraph<VertexType, WeightType, MAX_W, Direction> Self;

	public:
		AMGraph(const vector<VertexType>& arr, size_t arrSize)
		{
			/* 根据顶点序列，初始化邻接矩阵和其他相关信息 */
			_vertexs.reserve(arrSize);
			for (size_t i = 0; i < arrSize; ++i)
			{
				_vertexs.push_back(arr[i]);
				_indexMap[arr[i]] = (int)i;
			}

			_weights.resize(arrSize);
			for (size_t i = 0; i < arrSize; i++)
			{
				_weights[i].resize(arrSize, MAX_W);
			}
		}

		size_t GetVertexIndex(const VertexType& v)
		{
			/* 返回顶点对应的索引，并且有检查机制，防止用户输错顶点 */
			auto it = _indexMap.find(v);
			if (it != _indexMap.end())
			{
				return it->second;
			}
			throw invalid_argument("顶点不存在");//运行时报错
			return -1;//防止编译器警告
		}

		void _AddEdge(const size_t& srci, const size_t& dsti, const WeightType& w)
		{
			/* 添加边以及对应的权值（实际上可以理解为 AddEdge() 的重载版本，主要是方便某些传递坐标的情况，但是有可能发生语义不明确，所有就没有写成重载版本） */

			_weights[srci][dsti] = w;//链接
			if (Direction == false)//如果是无向图还需要镜像处理
			{
				_weights[dsti][srci] = w;
			}
		}
		void AddEdge(const VertexType& src, const VertexType& dst, const WeightType& w)
		{
			/* 添加边以及对应的权值 */
			size_t srci = GetVertexIndex(src);
			size_t dsti = GetVertexIndex(dst);

			_AddEdge(srci, dsti, w);
		}

		void Print()
		{
			/* 打印顶点集合和邻接矩阵来测试（只限于 int 类型的顶点数据） */
			int i = 0;
			for (auto ver : _vertexs)
			{
				cout << ver << " ";
			}
			cout << '\n';

			for (size_t i = 0; i < _weights.size(); i++)
			{
				for (size_t j = 0; j < _weights[i].size(); j++)
				{
					if (_weights[i][j] != INT_MAX)
					{
						printf("[%zd, %zd]:%-10d  ", i, j, _weights[i][j]);
					}
					else
					{
						printf("[%zd, %zd]:%-10d  ", i, j, 0);
					}
				}
				cout << '\n';
			}
			cout << '\n';
		}

		void BFS(const VertexType& src)
		{
			/* 广度优先遍历算法 */
			size_t srci = GetVertexIndex(src);

			queue<int> q; //队列
			q.push((int)srci);
			vector<bool> visited(_vertexs.size(), false); //标记位数组
			visited[srci] = true;

			size_t size = _vertexs.size();

			while (!q.empty())
			{
				//出队访问
				int front = q.front();
				q.pop();
				cout << _vertexs[front] << " ";

				//把 front 的邻接顶点入队
				for (size_t i = 0; i < size; i++)
				{
					if (_weights[front][i] != MAX_W && visited[i] == false)
					{
						q.push((int)i);
						visited[i] = true;
					}
				}
			}
			cout << '\n';
		}

		void _DFS(const size_t srci, vector<bool>& visited)
		{
			cout << _vertexs[srci] << " ";
			visited[srci] = true;

			//寻找下一个顶点
			for (size_t i = 0; i < _vertexs.size(); ++i)
			{
				if (_weights[srci][i] != MAX_W && visited[i] != true)
				{
					_DFS(i, visited);
				}
			}
		}
		void DFS(const VertexType& src)
		{
			/* 深度优先遍历算法 */
			size_t srci = GetVertexIndex(src);
			vector<bool> visited(_vertexs.size(), false);
			_DFS(srci, visited);
			cout << '\n';
		}

		struct Edge
		{
			/* 专门服务于 Kruskal 的结构体 */
			size_t _srci;
			size_t _dsti;
			const WeightType _weig;

			Edge(size_t srci, size_t dsti, WeightType weig)
				: _srci(srci), _dsti(dsti), _weig(weig)
			{}

			bool operator >(const Edge& e1, const Edge& e2) const
			{
				return e1._weig > e2._weig;
			}
		};
		WeightType Kruskal(Self& minTree)
		{
			/* 使用 Kruskal 算法给无向图生成最小生成树 */
			if (Direction != true)
			{
				priority_queue<Edge, vector<Edge>, greater<Edge>> minque;//存储较小的路径
				size_t n = _vertexs.size();//统计顶点个数

				//遍历邻接矩阵，如果有权值就插入优先级队列中
				for (size_t i = 0; i < n; i++)
				{
					for (size_t j = 0; j < n; j++)
					{
						if (i < j && _weights[i][j] != MAX_W)
						{
							minque.push(Edge(i, j, _weights[i][j]));
						}
					}
				}

				//选出 n-1 条边
				int count = n - 1;
				UnionFindSet<> ufs(n);
				while (count--)
				{
					Edge min = minque.top();
					minque.pop();

					if (ufs.InSet(min._srci, min._dsti))
					{
						minTree.AddEdge();
					}
				}
			}
		}

	private:
		vector<VertexType> _vertexs; //顶点表
		vector<vector<WeightType>> _weights; //邻接矩阵（无向图的时候表示链接关系，有向图的时候不仅可以查看是否有链接，还可以查看权值）
		map<VertexType, int> _indexMap; //顶点映射下标（主要是用来提高效率的）
	};

	void TestAMGraph()
	{
		string str = "ABCD";
		vector<char> vec(str.begin(), str.end());
		AMGraph<char, int, INT_MAX, true> amg(vec, 4);
		amg.AddEdge('A', 'B', 1);
		amg.AddEdge('A', 'D', 4);
		amg.AddEdge('B', 'D', 2);
		amg.AddEdge('B', 'C', 9);
		amg.AddEdge('C', 'D', 8);
		amg.AddEdge('C', 'B', 5);
		amg.AddEdge('C', 'A', 3);
		amg.AddEdge('D', 'C', 6);
		amg.Print();
	}

	void TestAMGraphBFS()
	{
		vector<string> vec = { "张三", "李四", "王五", "赵六", "周七" };
		AMGraph<string, int, INT_MAX> amg(vec, 5);
		amg.AddEdge("张三", "李四", 100);
		amg.AddEdge("张三", "王五", 200);
		amg.AddEdge("王五", "赵六", 30);
		amg.AddEdge("王五", "周七", 30);
		amg.BFS("张三");
		amg.BFS("李四");
		amg.DFS("赵六");
	}
}