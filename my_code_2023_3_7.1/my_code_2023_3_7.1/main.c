#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//日志
//1、指针第一题
//2、指针第二题
//3、指针第三题

//1、指针第一题
int main()
{
    int a[3][2] = { (0, 1), (2, 3), (4, 5) };//逗号表达式，实际存了1、3、5，然后剩下的默认为0
    int* p;
    p = a[0];//a[0]是一个数组名字，代表首元素地址，即a[0][0]的地址，类型是int*，正好存入p中
    printf("%d", p[0]);//p[0]等价于*(p+0)，即为1
    return 0;
}
//2、指针第二题
int main()
{
    int a[5][5];//二维数组
    int(*p)[4];//p保存了指向一个内含4个int元素的一维数组
    p = a;//a是二维数组数组名字，表示首元素地址，首元素是int(*)[5]，这里类型不匹配，强行把地址存进p了
    printf("%p, %d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
    return 0;
}
//3、指针第三题
int main()
{
    char* c[] = { "ENTER","NEW","POINT","FIRST" };//存放字符指针的数组，存放每个字符串的首元素地址
    char** cp[] = { c + 3,c + 2,c + 1,c };//存放字符指针的指针的数组，c是数组名，代表数组首元素地址，c+3得到c数组的第四个元素（元素类型为char*）的地址，c+2得到c数组的第三个元素地址，c+1得到c数组的第二个元素地址，c得到c数组首元素地址
    char*** cpp = cp;//cpp是字符指针的指针的指针类型，cp是cp数组的首元素地址，cp数组的首元素是c+3，其类型为char**，则cp的地址的类型为char***，刚好存进去cpp
    printf("%s\n", **++cpp);//先++在解引用cpp，cpp+1的意思是跳过一个char**，解引用一次得到cp指向的元素，即cp数组的首元素c+3，再次解引用c+3，得到c数组的第四个元素，即"F"的地址，因此打印出FIRST
    printf("%s\n", *-- * ++cpp + 3);
    printf("%s\n", *cpp[-2] + 3);
    printf("%s\n", cpp[-1][-1] + 1);
    return 0;
}