#define _CRT_SECURE_NO_WARNINGS 1
#include<easyx.h>
#include<stdio.h>
#include<windows.h>
#include<conio.h>
#define NODE_WIDTH 40
//<一、自定义封装结构体>
//=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
typedef struct//①封装坐标结构体（节点的网格段XY坐标）
{
	int x;
	int y;
}node;
enum direction//②封装方向枚举体
{
	eUp,//上
	eDown,//下
	eLeft,//左
	eRight//右
};
//=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//<二、自定义封装函数>
//=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
void paintGrid()//①画网格函数
{
	for (int x = 0; x <= 800; x += NODE_WIDTH)
	{
		line(x, 0, x, 600);
	}
	for (int y = 0; y <= 600; y += NODE_WIDTH)
	{
		line(0, y, 800, y);
	}
}
void paintSnake(node* snake, int n)//②初始化画蛇函数
{//（蛇的坐标结构体指针，蛇的节点数量）
	int left, top, right, bottom;//某一段蛇节点的左上、右下坐标
	for (int i = 0; i < n; i++)
	{
		left = snake[i].x * NODE_WIDTH;
		top = snake[i].y * NODE_WIDTH;
		right = (snake[i].x + 1) * NODE_WIDTH;
		bottom = (snake[i].y + 1) * NODE_WIDTH;

		solidrectangle(left, top, right, bottom);//画蛇的一个小节点
	}
}
void snakeMove(node* snake, int length, int direction)//③生成新的坐标数组函数
{//（蛇的坐标结构体数组指针，蛇的节点个数，蛇的前进方向）
	for (int i = length - 1; i > 0; i--)
	{
		snake[i] = snake[i - 1];//让后面的数组变成前面的数组，即将每个前面的节点覆盖掉后面的节点（蛇头在前，蛇尾在后），蛇头节点后续再根据方向进行重定义坐标
	}

	node newHead;//创建新的蛇头坐标变量
	newHead = snake[0];//将原蛇头的坐标传到上面的变量中
	//根据键盘输入方向改变新的蛇头坐标（注意枚举体的运用，枚举体内部成员在这里可以直接写出来）
	if (direction == eUp)
	{
		newHead.y--;
	}
	else if (direction == eDown)
	{
		newHead.y++;
	}
	else if (direction == eLeft)
	{
		newHead.x--;
	}
	else
	{
		newHead.x++;
	}
	snake[0] = newHead;//赋予新的头
}
void changeDirection(enum direction* pD)//④输入方向函数
{//（枚举体指针变量）
	if (_kbhit() != 0)//查看缓冲区是不是空的
	{
		char c = _getch();//输入a、s、d、w四个方向键到c中
		switch (c)
		{
			case 'w':
				if (*pD != eDown)//如果原蛇头方向不是向下才可以向上
				*pD = eUp;
				break;
			case 's':
				if (*pD != eUp)//如果原蛇头方向不是向上才可以向下
				*pD = eDown;
				break;
			case 'a':
				if (*pD != eRight)//如果原蛇头方向不是向右才可以向左
				*pD = eLeft;
				break;
			case 'd':
				if (*pD != eLeft)//如果原蛇头方向不是向左才可以向右
				*pD = eRight;
				break;
		}
	}
}
//=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+






//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//前提说明：
//<网格水平20等分，竖直15等份（从0开始）>
//<蛇用白色的矩形格子表示，食物为一矩形格子黄色>
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//<主函数部分>
int main()
{
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//<基础设置>
	initgraph(800, 600, EX_SHOWCONSOLE);//创建一个窗体
	setbkcolor(RGB(164, 225, 202));//背景颜色属性
	cleardevice();//刷新背景颜色
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//<默认逻辑坐标原点为物理坐标原点>
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//<初始化蛇>
	node snake[100] = { {5,7},{4,7},{3,7},{2,7},{1,7} };//初始蛇，下标为0、1、2、3、4
	int length = 5;//蛇的初始长度
	enum direction d = eRight;//默认初始化蛇头的方向是向右
	while (1)
	{
		cleardevice();//清空全屏窗体
		paintGrid();//绘制网格函数
		paintSnake(snake, length);//画出初始化后的蛇（以及坐标数组更新后的蛇）
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//<停滞500毫秒>
		Sleep(500);
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//<检查键盘输入>
		changeDirection(&d);//检查是否有键盘输入，有的话修改蛇头的方向
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//<更新蛇的坐标>
		snakeMove(snake, length, d);//改变蛇头方向后的新坐标数组
	}
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	getchar();
	closegraph();
	return 0;
}