#define _CRT_SECURE_NO_WARNINGS 1
//日志
//探寻数组和指针的差异
#include <stdio.h>
#include <string.h>
int main()
{
    //一维数组
    int a[] = { 1,2,3,4 };
    printf("%d\n", sizeof(a));//16
    printf("%d\n", sizeof(a + 0));//4或者8，注意这里的数组名a受到+0的影响，a是首元素地址
    printf("%d\n", sizeof(*a));//4，注意这里的数组名a受到*的影响，a是首元素地址，(*a)则找到了一个首元素
    printf("%d\n", sizeof(a + 1));//4或者8，注意这里的数组名a受到+1的影响，a是首元素地址，(a+1)是数组的第二个元素
    printf("%d\n", sizeof(a[1]));//4，就是第二个元素
    printf("%d\n", sizeof(&a));//这里取出来的地址是数组的整个地址，但是也是地址，因此是4或者8。不要理解为二级指针！！！
    printf("%d\n", sizeof(*&a));//16，(*(&a))就是取出整个数组
    printf("%d\n", sizeof(&a + 1));//4或者8，&a取出整个数组地址，+1后跳过一个指针
    printf("%d\n", sizeof(&a[0]));//4或者8，首元素地址，依旧是地址
    printf("%d\n", sizeof(&a[0] + 1));//4或者8，第二个元素的地址，依旧是地址
    //------------------------------------------------------------
    //字符数组
    char arr[] = { 'a','b','c','d','e','f' };
    printf("%d\n", sizeof(arr));//6，arr是整个数组
    printf("%d\n", sizeof(arr + 0));//4或者8，arr受到+0的影响，是首元素地址，还是地址
    printf("%d\n", sizeof(*arr));//1，这里arr受到*的影响，是数组首元素地址，*arr解引用首元素地址得到首元素
    printf("%d\n", sizeof(arr[1]));//1，arr[1]是数组第二个元素
    printf("%d\n", sizeof(&arr));//4或者8，&arr是取出了整个数组的地址，还是地址
    printf("%d\n", sizeof(&arr + 1));//4或者8，&arr取出了整个数组，+1跳过了以个数组，得到一个地址，依旧是地址
    printf("%d\n", sizeof(&arr[0] + 1));//4或者8，&arr[0]取出首元素的地址，+1后得到第二个元素的地址，还是地址
    printf("%d\n", strlen(arr));//随机值，因为没有\0
    printf("%d\n", strlen(arr + 0));//随机值，因为没有\0
    printf("%d\n", strlen(*arr));//传参错误，strlen传进去应该是地址，而这里传进去了一个字符(*arr)，出现error，非法访问（越界访问）。而且在函数strlen中会解引用传进来的地址，因此解引用了'c'，即：解引用97，在VS2022会发生“已引发异常”的警告。
    printf("%d\n", strlen(arr[1]));//传参错误，strlen传进去应该是地址，而这里传进去了一个字符(arr[1])，出现error，非法访问（越界访问），在VS2022会发生“已引发异常”的警告
    printf("%d\n", strlen(&arr));//随机值，因为没有\0。注意和上一条的随机值是一样的，都要访问后面的字符
    printf("%d\n", strlen(&arr + 1));//随机值，因为没有\0。注意和上一条的随机值是不太一样的，一定比上一条长度差6
    printf("%d\n", strlen(&arr[0] + 1));//随机值，因为没有\0。注意比strlen(&arr)的随机值差了个1

    char arr[] = "abcdef";
    printf("%d\n", sizeof(arr));//7，arr就是整个数组的地址，注意'\0'也要算进去
    printf("%d\n", sizeof(arr + 0));//4或者8，arr受到+0的影响，是首元素地址的指针，arr+0则是首元素地址，还是地址
    printf("%d\n", sizeof(*arr));//1，受到*影响，arr是首元素地址，*arr解引用首元素地址得到首元素。可以利用这一点写sizeof(arr)/sizeof(arr[0])为sizeof(arr)/sizeof(*arr)
    printf("%d\n", sizeof(arr[1]));//1，arr[1]就是第二个元素
    printf("%d\n", sizeof(&arr));//4或者8，&arr取出了整个数组的地址，还是地址
    printf("%d\n", sizeof(&arr + 1));//4或者8，&arr取出整个地址，+1跳过了一个大小为7的数组地址，但是还是地址
    printf("%d\n", sizeof(&arr[0] + 1));//4或者8，&arr[0]+1得到第二个元素的地址，还是地址
    printf("%d\n", strlen(arr));//6，计算出字符串长度
    printf("%d\n", strlen(arr + 0));//6，arr受到+0的影响，arr是一个首元素地址，+0还是首元素地址，strlen的参数就是一个地址，解引用后，就从首元素一直往后面找'\0'，找到就停下，因此还是6
    printf("%d\n", strlen(*arr));//传参错误，strlen传进去应该是地址，而这里传进去了一个字符(*arr)，出现error，非法访问（越界访问）。
    printf("%d\n", strlen(arr[1]));//传参错误，strlen传进去应该是地址，而这里传进去了一个字符(*arr)，出现error，非法访问（越界访问）。
    printf("%d\n", strlen(&arr));//6，&arr取出整个数组的地址，虽然指针的类型是指向整个数组，但是由于形参的类型是char*，它把传过来的指针类型自动强制类型转换了（所以这里如果是vs2022，这里会出现一个类型不匹配的警告，但是不影响使用），而&arr的值和arr数组的首元素地址值相同，故在strlen函数内部，指针++的时候，依旧是按照一个又一个字符地址的顺序解引用，直到找到'\0'就停止，因此求出来还是6
    /*这个头文件中strlen的声明
    size_t __cdecl strlen(
        _In_z_ char const* _Str
        );
    */
    printf("%d\n", strlen(&arr + 1));//随机值，和上面的代码有点类似，但是由于取出整个数组的地址后，+1跳过了一个数组地址，后面没有固定的'\0'
    printf("%d\n", strlen(&arr[0] + 1));//6，&arr[0]得到首元素地址，+1得到第二个元素的地址，因此从第二个元素地址开始向后解引用，直到找到'\0'为止

    char* p = "abcdef";
    printf("%d\n", sizeof(p));//4或者8，传入了一个char*类型的地址，还是一个地址
    printf("%d\n", sizeof(p + 1));//4或者6，p是首元素地址，p+1就是第二个元素地址，还是地址
    printf("%d\n", sizeof(*p));//1，*p得到的是一个元素
    printf("%d\n", sizeof(p[0]));//1，p[0]还是第一个元素
    printf("%d\n", sizeof(&p));//4或者8，&p得到指针的指针
    printf("%d\n", sizeof(&p + 1));//4或者8，指针的指针+1，还是地址。注意p是char*类型，指向一个char；&p是char**类型，指向一个char*。因此跳过一个p的地址
    printf("%d\n", sizeof(&p[0] + 1));//4或者8，&p[0]取出首元素地址，&p[0]+1得到第二个元素的地址，还是地址
    printf("%d\n", strlen(p));//6，p是字符串首元素的地址，从第一个元素地址开始解引用，直到找到'\0'
    printf("%d\n", strlen(p + 1));//5，p+1是第二个元素的地址，从第二个元素地址开始解引用，直到找到'\0'
    printf("%d\n", strlen(*p));//传参错误，解引用得到字符，越界访问
    printf("%d\n", strlen(p[0]));//传参错误，解引用得到字符，越界访问
    printf("%d\n", strlen(&p));//随机值，p是char*类型指针，&p是char**类型指针，被强制转化为char*类型的指针，但是没办法确定&p的地址后面是否有'\0'的地址，故随机值
    printf("%d\n", strlen(&p + 1));//随机值，产生的随机值和上面的随机值没有关系（因为已经&p+1已经跳过一个p了，如果p的后面就有'\0'地址，&p+1这个地址可能比'\0'的地址还靠后）
    printf("%d\n", strlen(&p[0] + 1));//5，&p[0]是首元素地址，+1就是下一个元素地址，从第二个元素的地址开始解引用，直到找到'\0'为止
    //------------------------------------------------------------
    //二维数组
    //这一部分要深刻理解好一个概念：例如定义了int a[3][4]后，则a[0][1]是指一个名字为a[0]的数组的第二个元素，a[0]+1就是第一行数组的第二个元素的地址
    int a[3][4] = { 0 };
    printf("%d\n", sizeof(a));//48，注意这里的a是整个数组！！！因此计算每个数组的大小
    printf("%d\n", sizeof(a[0][0]));//4，a[0][0]就是一个数组元素
    printf("%d\n", sizeof(a[0]));//16，a[0]是第一行数组的数组名字，即整个数组的地址，内含有4个元素，计算的是整个行数组的大小
    printf("%d\n", sizeof(a[0] + 1));//4或者8，a[0]原本是一个第一行数组的名字，受到+1影响，这里的a[0]不再是整个行数组地址，而是该行首元素地址a[0]+1得到这一行的第二个元素地址，还是地址
    printf("%d\n", sizeof(*(a[0] + 1)));//4，(a[0]+1)是第一行数组的第二个元素地址，对这个地址解引用得到a[0][1]这个元素，这个元素类型是int
    printf("%d\n", sizeof(a + 1));//4或者8，a受到+1影响，a代表二维数组的首元素地址，即指向第一行的地址，+1后得到第二行的地址，还是地址
    printf("%d\n", sizeof(*(a + 1)));//16，a受到+1的影响，a代表第一行的地址，a+1后得到第二行的地址，对这个地址解引用得到整个第二行，类型是int[4]，计算出整个行数组的大小
    printf("%d\n", sizeof(&a[0] + 1));//4或者8，&a[0]是整个第一行数组的地址，+1得到整个第二行数组的地址，依旧是地址
    printf("%d\n", sizeof(*(&a[0] + 1)));//16，&a[0]是整个第一行地址，+1得到整个第二行地址，对这个地址解引用，得到整个第二行数组，类型为int[4]，因此计算整个第二行数组大小
    printf("%d\n", sizeof(*a));//16，受到*影响，a是首元素地址，解引用得到整个第一行数组，类型为int[4]，故计算整个数组的大小
    printf("%d\n", sizeof(a[3]));//16，a[3]是第四行数组的数组名字，故计算整个第四行数组的大小。但是注意sizeof只通过类型计算大小，不需要进行运算，并且在编译过后就直接替换了原本的整个sizeof表达式，因此这里不属于越界访问
}