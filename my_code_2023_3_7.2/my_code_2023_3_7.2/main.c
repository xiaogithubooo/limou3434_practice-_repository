#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int main()
{
    char* c[] = { "ENTER","NEW","POINT","FIRST" };
    //c数组是一个存放字符指针的数组，存放每个字符串的首元素地址
    char** cp[] = { c + 3,c + 2,c + 1,c };
    //cp数组是一个存放字符指针的指针的数组，c是c数组的数组名，代表c数组首元素地址，c+3得到c数组的第四个元素（第四个元素类型为char*）的地址（地址类型为char**），c+2得到c数组的第三个元素地址，c+1得到c数组的第二个元素地址，c得到c数组首元素地址
    char*** cpp = cp;
    //cpp是字符指针的指针的指针类型，cp是cp数组的首元素地址，cp数组的首元素是c+3，其类型为char**，则cp的地址的类型为char***，刚好存进去cpp这个变量

    printf("%s\n", **++cpp);
    //先++在解引用cpp，cpp+1的意思是跳过一个char**，此时cpp存的是c+2的地址，解引用一次得到c+2，再解引用后得到c数组的第三个元素，这个元素就是"FIRST"得首元素地址，根据这个元素可以打印出"FIRST"

    printf("%s\n", (*--(*(++cpp))) + 3);
    //上面的cpp被++了具有副作用，故cpp存的还是c+2的地址，因此++cpp则使得cpp存储了c+1的地址，解引用得到(c+1)，对(c+1)这个地址（地址类型为char**）-1，跳过一个char**，得到c，再解引用c，得到c数组的第一个元素（即字符'E'的地址），这个元素的类型是char*，+3代表跳过三个char*，则得到字符'E'的地址，因此输出"ER"

    printf("%s\n", *(cpp[-2]) + 3);
    //注意此前cpp被++了两次，都具有副作用，cpp指向c+1的地址。cpp[-2]可以理解为*(cpp-2)，(cpp-2)整体是一个cp数组的第0个元素的地址，解引用这个地址得到第0个元素，即c+3，这个元素的类型是char**，对char**解引用得到类型为char*的数据，即字符"F"的地址，对这个地址+3，得到字符'S'的地址，因此输出"ST"

    printf("%s\n", cpp[-1][-1] + 1);
    //注意此前cpp被++了两次，都具有副作用，cpp指向c+1的地址。cpp[-1][-1]代表*( (*(cpp-1)) -1)，cpp-1得到c+2的地址*(cpp-1)得到c+2，而这个元素类型是char**，-1又得到c+1，解引用( (*(cpp-1)) -1)这个整体就是解引用c+1，得到字符'N'的地址，由于cpp[-1][-1]+1（后面还有个加1），所以有进一步得到字符'E'的地址，因此输出"EW"
    return 0;
}